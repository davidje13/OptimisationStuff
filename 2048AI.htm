<html>
<head>
<script>
function makeAI( ) {
	// Chrome doesn't set which when a key event is triggered, so that can't work,
	// and touch events don't seem to be triggerable at all. Also since the instances
	// of 2048 are all private, the only way to get one is by this nasty hack. Turns out
	// that the direct .move method is pulled out in the constructor, so we can't even
	// use that; have to pull a random event dispatcher from the input manager!
	
	var thinkingCode = new Blob( ["'use strict';\n\
	var \n\
	lftrgt = new Uint16Array( 131072 ), \n\
	scx = new Uint16Array( 65536 ), \n\
	scy = new Uint16Array( 65536 ), \n\
	mx = new Uint8Array( 65536 ), \n\
	hashes = new Float32Array( 0x10000 ), \n\
	hMap = new Uint16Array( hashes.length * 4 ); \n\
	for( var i = 0; i < 65536; ++ i ) { \n\
		lftrgt[ i<<1   ] = moveRowLeft( i ); \n\
		lftrgt[(i<<1)|1] = swap( moveRowLeft( swap( i ) ) ); \n\
		scx[i] = (scy[i] = scoreRow( i )) + scoreRowGen( i ); \n\
		mx[i] = scoreRowEnd( i ); \n\
	} \n\
	function swap( v ) { \n\
		return (v >>> 12) | ((v >>> 4) & 0xF0) | ((v << 4) & 0xF00) | ((v << 12) & 0xF000); \n\
	} \n\
	function moveRowLeft( s ) { \n\
		var i, j, g = 0, p = 0, c, v = 0; \n\
		for( i = 0; i < 16; i += 4 ) { \n\
			c = (s >>> i) & 0xF; \n\
			if( !c ) { \n\
			} else if( c === p ) { \n\
				v &= ~(0xF << (g - 4)); \n\
				v |= (p + 1) << (g - 4); \n\
				p = 0; \n\
			} else { \n\
				v |= (p = c) << g; \n\
				g += 4; \n\
			} \n\
		} \n\
		return v; \n\
	} \n\
	function scoreRow( s ) { \n\
		var \n\
		i, v = 0, a, b, t = 0; \n\
		for( i = 1; i < 4; ++ i ) { \n\
			a = (s >>> (i * 4    )) & 0xF; \n\
			b = (s >>> (i * 4 - 4)) & 0xF; \n\
//			v += ((a === b) ? 0 : (a > b) ? 8 : -8) * ((a > b) ? a : b); \n\
			if( a === b ) { \n\
				t += 5 * a; \n\
			} else if( a === b + 1 ) { \n\
				v += 8 * (a + b); \n\
			} else if( a === b - 1 ) { \n\
				v -= 8 * (a + b); \n\
			} else { \n\
				v += ((a > b) ? 3 : -3) * (a + b); \n\
			} \n\
		} \n\
		return t + ((v > 0) ? v : -v); \n\
	} \n\
	function scoreRowGen( s ) { \n\
		return ( \n\
			!( s        & 0xF) + \n\
			!((s >>> 4) & 0xF) + \n\
			!((s >>> 8) & 0xF) + \n\
			! (s >>>12) \n\
		) * 512; \n\
	} \n\
	function scoreRowEnd( s ) { \n\
		var best = 0; \n\
		if( (s & 0xF) > best ) { \n\
			best = s & 0xF; \n\
		} \n\
		if( ((s >>> 4) & 0xF) > best ) { \n\
			best = (s >>> 4) & 0xF; \n\
		} \n\
		if( ((s >>> 8) & 0xF) > best ) { \n\
			best = (s >>> 8) & 0xF; \n\
		} \n\
		if( (s >>> 12) > best ) { \n\
			best = (s >>> 12); \n\
		} \n\
		return best; \n\
	} \n\
	\
	\
	\
	function score( grid, N ) { \n\
		return scx[grid[N]] + scy[ \n\
			 (grid[N  ] & 0xF)       | \n\
			((grid[N|1] & 0xF) << 4) | \n\
			((grid[N|2] & 0xF) << 8) | \n\
			((grid[N|3] & 0xF) <<12) \n\
		] + scx[grid[N|1]] + scy[ \n\
			((grid[N  ] >>>4) & 0xF) | \n\
			 (grid[N|1]       & 0xF0) | \n\
			((grid[N|2] << 4) & 0xF00) | \n\
			((grid[N|3] << 8) & 0xF000) \n\
		] + scx[grid[N|2]] + scy[ \n\
			((grid[N  ] >>>8) & 0xF) | \n\
			((grid[N|1] >>>4) & 0xF0) | \n\
			 (grid[N|2]       & 0xF00) | \n\
			((grid[N|3] << 4) & 0xF000) \n\
		] + scx[grid[N|3]] + scy[ \n\
			 (grid[N  ] >>>12) | \n\
			((grid[N|1] >>> 8) & 0xF0) | \n\
			((grid[N|2] >>> 4) & 0xF00) | \n\
			 (grid[N|3] & 0xF000) \n\
		] + 2048; \n\
	} \n\
	function scoreEnd( grid, N ) { \n\
		var \n\
		best = mx[grid[N]], \n\
		r = mx[grid[N|1]]; \n\
		if( r > best ) { \n\
			best = r; \n\
		} \n\
		r = mx[grid[N|2]]; \n\
		if( r > best ) { \n\
			best = r; \n\
		} \n\
		r = mx[grid[N|3]]; \n\
		if( r > best ) { \n\
			best = r; \n\
		} \n\
		return best * 10; \n\
	} \n\
	function simulate( grid, cache, N, lowp ) { \n\
		if( grid.length === N + 4 || lowp === 3 ) { \n\
			return score( grid, N ); \n\
		} \n\
		var \n\
		i, j, pX, v, \n\
		s = 0.0, \n\
		t = 0, \n\
		h = (grid[N] ^ (grid[N|1] << 7) ^ (grid[N|2] << 2) ^ (grid[N|3] << 13)); \n\
		h = ((h ^ (h >>> 16)) & 0xFFFF) << 2; \n\
		if( hMap[h] === grid[N] && hMap[h|1] === grid[N|1] && hMap[h|2] === grid[N|2] ) { \n\
			return hashes[h>>2]; \n\
		} \n\
		hMap[h  ] = grid[N  ]; \n\
		hMap[h|1] = grid[N|1]; \n\
		hMap[h|2] = grid[N|2]; \n\
		if( !(grid[N] & 0xF) ) { \n\
			++ t; \n\
			// add 2 with p = 0.9 \n\
			grid[N] |= 2; \n\
			pX = thinkX( grid, cache, N, lowp ) * 9; \n\
			v = thinkY( grid, cache, N, lowp ) * 9; \n\
			// add 4 with p = 0.1 \n\
			grid[N] |= 3; \n\
			pX += thinkX( grid, cache, N, lowp + 1 ); \n\
			v += thinkY( grid, cache, N, lowp + 1 ); \n\
			s += (v > pX) ? v : pX; \n\
			cache[N] = v; \n\
			grid[N] ^= 3; \n\
		} \n\
		for( i = 4; i < 16; i += 4 ) { \n\
			if( !((grid[N] >>> i) & 0xF) ) { \n\
				++ t; \n\
				grid[N] |= 2 << i; \n\
				if( (grid[N] >>> (i - 4)) & 0xF ) { \n\
					// add 2 with p = 0.9 \n\
					pX = thinkX( grid, cache, N, lowp ) * 9; \n\
					// add 4 with p = 0.1 \n\
					grid[N] |= 3 << i; \n\
					pX += thinkX( grid, cache, N, lowp + 1 ); \n\
					grid[N] ^= 1 << i; \n\
				} \n\
				// add 2 with p = 0.9 \n\
				v = thinkY( grid, cache, N, lowp ) * 9; \n\
				// add 4 with p = 0.1 \n\
				grid[N] |= 3 << i; \n\
				v += thinkY( grid, cache, N, lowp + 1 ); \n\
				s += (v > pX) ? v : pX; \n\
				cache[N|(i>>>2)] = v; \n\
				grid[N] ^= 3 << i; \n\
			} \n\
		} \n\
		for( j = 1; j < 4; ++ j ) { \n\
			if( !(grid[N|j] & 0xF) ) { \n\
				++ t; \n\
				// add 2 with p = 0.9 \n\
				grid[N|j] |= 2; \n\
				pX = thinkX( grid, cache, N, lowp ) * 9; \n\
				// add 4 with p = 0.1 \n\
				grid[N|j] |= 3; \n\
				pX += thinkX( grid, cache, N, lowp + 1 ); \n\
				if( !(grid[N|(j-1)] & 0xF) ) { \n\
					// add 2 with p = 0.9 \n\
					grid[N|j] ^= 1; \n\
					v = thinkY( grid, cache, N, lowp ) * 9; \n\
					// add 4 with p = 0.1 \n\
					grid[N|j] |= 3; \n\
					v += thinkY( grid, cache, N, lowp + 1 ); \n\
					cache[N] = v; \n\
				} else { \n\
					v = cache[N]; \n\
				} \n\
				s += (v > pX) ? v : pX; \n\
				grid[N|j] ^= 3; \n\
			} \n\
			for( i = 4; i < 16; i += 4 ) { \n\
				if( !((grid[N|j] >>> i) & 0xF) ) { \n\
					++ t; \n\
					if( (grid[N|j] >>> (i - 4)) & 0xF ) { \n\
						// add 2 with p = 0.9 \n\
						grid[N|j] |= 2 << i; \n\
						pX = thinkX( grid, cache, N, lowp ) * 9; \n\
						// add 4 with p = 0.1 \n\
						grid[N|j] |= 3 << i; \n\
						pX += thinkX( grid, cache, N, lowp + 1 ); \n\
						grid[N|j] ^= 3 << i; \n\
					} \n\
					if( (grid[N|(j-1)] >>> i) & 0xF ) { \n\
						// add 2 with p = 0.9 \n\
						grid[N|j] |= 2 << i; \n\
						v = thinkY( grid, cache, N, lowp ) * 9; \n\
						// add 4 with p = 0.1 \n\
						grid[N|j] |= 3 << i; \n\
						v += thinkY( grid, cache, N, lowp + 1 ); \n\
						grid[N|j] ^= 3 << i; \n\
						cache[N|(i>>>2)] = v; \n\
					} else { \n\
						v = cache[N|(i>>>2)]; \n\
					} \n\
					s += (v > pX) ? v : pX; \n\
				} \n\
			} \n\
		} \n\
		return hashes[h>>2] = s * 0.1 / t + 1; \n\
	} \n\
	function moveY( grid, N, rgt ) { \n\
		var i, v, w, ok, \n\
		n0 = grid[N  ], \n\
		n1 = grid[N|1], \n\
		n2 = grid[N|2], \n\
		n3 = grid[N|3]; \n\
		v =  (n0 & 0xF)       | \n\
		    ((n1 & 0xF) << 4) | \n\
		    ((n2 & 0xF) << 8) | \n\
		    ((n3 & 0xF) <<12); \n\
		ok = ((w = lftrgt[(v<<1)|rgt]) !== v); \n\
		grid[N+4] = ( w        & 0xF); \n\
		grid[N+5] = ((w >>> 4) & 0xF); \n\
		grid[N+6] = ((w >>> 8) & 0xF); \n\
		grid[N+7] =  (w >>>12); \n\
		v = ((n0 >>> 4) & 0xF) | \n\
		     (n1        & 0xF0) | \n\
		    ((n2 <<  4) & 0xF00) | \n\
		    ((n3 <<  8) & 0xF000); \n\
		ok |= ((w = lftrgt[(v<<1)|rgt]) !== v); \n\
		grid[N+4] |= ((w << 4) & 0xF0); \n\
		grid[N+5] |= ( w       & 0xF0); \n\
		grid[N+6] |= ((w >>>4) & 0xF0); \n\
		grid[N+7] |= ((w >>>8) & 0xF0); \n\
		v = ((n0 >>> 8) & 0xF) | \n\
		    ((n1 >>> 4) & 0xF0) | \n\
		     (n2        & 0xF00) | \n\
		    ((n3 <<  4) & 0xF000); \n\
		ok |= ((w = lftrgt[(v<<1)|rgt]) !== v); \n\
		grid[N+4] |= ((w << 8) & 0xF00); \n\
		grid[N+5] |= ((w << 4) & 0xF00); \n\
		grid[N+6] |= ( w       & 0xF00); \n\
		grid[N+7] |= ((w >>>4) & 0xF00); \n\
		v =  (n0 >>>12) | \n\
		    ((n1 >>> 8) & 0xF0) | \n\
		    ((n2 >>> 4) & 0xF00) | \n\
		    ( n3        & 0xF000); \n\
		ok |= ((w = lftrgt[(v<<1)|rgt]) !== v); \n\
		grid[N+4] |= ((w <<12) & 0xF000); \n\
		grid[N+5] |= ((w << 8) & 0xF000); \n\
		grid[N+6] |= ((w << 4) & 0xF000); \n\
		grid[N+7] |= ( w       & 0xF000); \n\
		return ok; \n\
	} \n\
	function moveX( grid, N, rgt ) { \n\
		return ( \n\
			((grid[N+4] = lftrgt[(grid[N  ]<<1)|rgt]) !== grid[N  ]) | \n\
			((grid[N+5] = lftrgt[(grid[N|1]<<1)|rgt]) !== grid[N|1]) | \n\
			((grid[N+6] = lftrgt[(grid[N|2]<<1)|rgt]) !== grid[N|2]) | \n\
			((grid[N+7] = lftrgt[(grid[N|3]<<1)|rgt]) !== grid[N|3])   \n\
		); \n\
	} \n\
	function thinkX( grid, cache, N, lowp ) { \n\
		var best = -1.0, s = 0.0; \n\
		if( moveX( grid, N, 0 ) ) { \n\
			best = simulate( grid, cache, N + 4, lowp ); \n\
		} \n\
		if( moveX( grid, N, 1 ) ) { \n\
			s = simulate( grid, cache, N + 4, lowp ); \n\
			return (s > best) ? s : best; \n\
		} \n\
		return (best === -1.0) ? scoreEnd( grid, N ) : best; \n\
	} \n\
	function thinkY( grid, cache, N, lowp ) { \n\
		var best = -1.0, s = 0.0; \n\
		if( moveY( grid, N, 0 ) ) { \n\
			best = simulate( grid, cache, N + 4, lowp ); \n\
		} \n\
		if( moveY( grid, N, 1 ) ) { \n\
			s = simulate( grid, cache, N + 4, lowp ); \n\
			return (s > best) ? s : best; \n\
		} \n\
		return (best === -1.0) ? scoreEnd( grid, N ) : best; \n\
	} \n\
	var moves = { 'up': moveY, 'down': moveY, 'left': moveX, 'right': moveX }; \n\
	self.onmessage = function( e ) { \n\
		var \n\
		l = e.data.l | 0, \n\
		dir = e.data.dir, \n\
		grid = new Uint16Array( 4 * l ); \n\
		grid.set( e.data.grid ); \n\
		if( !moves[dir]( grid, 0, dir === 'right' || dir === 'down' ) ) { \n\
			self.postMessage( { dir: dir, score: -1 } ); \n\
			return; \n\
		} \n\
		if( moveY( grid, 0, 0 ) + moveY( grid, 0, 1 ) + moveX( grid, 0, 0 ) + moveX( grid, 0, 1 ) === 1 ) { \n\
			self.postMessage( { dir: dir, score: 0 } ); \n\
			return; \n\
		} \n\
		var cache = new Float32Array( 4 * l ); \n\
		for( var i = 0; i < hMap.length; ++ i ) { \n\
			hMap[i] = 0; \n\
		} \n\
		moves[dir]( grid, 0, dir === 'right' || dir === 'down' ); \n\
		self.postMessage( { dir: dir, score: simulate( grid, cache, 4, 0 ) } ); \n\
	} \n\
	"], { type: 'text/javascript' } ),
	thinkingURL = window.URL.createObjectURL( thinkingCode ),
	workerUp    = new Worker( thinkingURL ),
	workerLeft  = new Worker( thinkingURL ),
	workerRight = new Worker( thinkingURL ),
	workerDown  = new Worker( thinkingURL ),
	source,
	target,
	realEmit = KeyboardInputManager.prototype.emit,
	autorun,
	nextrun,
	hadwon = false;
	KeyboardInputManager.prototype.emit = function( ) {
		target = this;
		KeyboardInputManager.prototype.emit = realEmit;
		console.log( 'Got target:', target );
		if( autorun ) {
			autorun( );
			autorun = undefined;
		}
	};
	HTMLActuator.prototype.actuate2 = HTMLActuator.prototype.actuate;
	HTMLActuator.prototype.actuate = function( grid, meta ) {
		source = grid;
		this.actuate2( grid, meta );
		var n = nextrun, win = meta.won && !hadwon;
		hadwon = meta.won;
		if( n ) {
			nextrun = undefined;
			n( win );
		}
	}
	
	function perform( dir ) {
		if( dir === 'continue' ) {
			target.emit( 'keepPlaying' );
		} else {
			target.emit( 'move', {
				'up': 0,
				'right': 1,
				'down': 2,
				'left': 3
			}[dir] );
		}
	}
	
	function autoplay( lookahead, minTime ) {
		if( !target ) {
			alert( 'Press a random direction to begin' );
			autorun = function( ) {
				autoplay( lookahead, minTime );
			}
			return;
		}
		function result( dir, depth ) {
			if( dir ) {
				document.getElementsByClassName( 'title' )[0].innerText = depth;
				nextrun = turn;
				perform( dir );
			} else {
				console && console.log( 'Game Over.' );
			}
		}
		function turn( win ) {
			if( win ) {
				hadwon = true;
				console && console.log( 'celebrating success' );
				setTimeout( turn, 1000 ); // wait for win screen to appear
				return;
			}
			if( document.getElementsByClassName( 'game-won' ).length ) {
				console && console.log( 'getting on with it' );
				perform( 'continue' );
			}
			play( lookahead, minTime, result );
		}
		console && console.log( 'Thinking...' );
		hadwon = false;
		setTimeout( turn, 0 );
	}
	
	function play( lookahead, minTime, call ) {
		lookahead = (lookahead | 0) || 6;
		if( lookahead < 2 ) {
			lookahead = 2;
		}
		var
		l = lookahead + 1,
		limit = Date.now( ) + (minTime || 20),
		grid = new Uint16Array( 4 ),
		scores;
		function go( ) {
			scores = {
				'up': undefined,
				'down': undefined,
				'left': undefined,
				'right': undefined
			};
			workerUp.postMessage( { dir: 'up', grid: grid, l: l } );
			workerDown.postMessage( { dir: 'down', grid: grid, l: l } );
			workerLeft.postMessage( { dir: 'left', grid: grid, l: l } );
			workerRight.postMessage( { dir: 'right', grid: grid, l: l } );
		}
		read( grid );
		workerUp.onmessage =
		workerDown.onmessage =
		workerLeft.onmessage =
		workerRight.onmessage =
		function( e ) {
			scores[e.data.dir] = e.data.score;
			if( scores.up === undefined || scores.down === undefined || scores.left === undefined || scores.right === undefined ) {
				return;
			}
			var
			best = scores.up,
			dir = 'up';
			if( scores.down > best ) {
				best = scores.down;
				dir = 'down';
			}
			if( scores.left > best ) {
				best = scores.left;
				dir = 'left';
			}
			if( scores.right > best ) {
				best = scores.right;
				dir = 'right';
			}
			if( best === -1 ) {
				call( '', l - 1 );
			} else if( best && Date.now( ) < limit && l < lookahead * 4 ) {
				++ l;
				go( );
			} else {
				call( dir, l - 1 );
			}
		}
		go( );
	}
	
	function test( ) {
		var grid = new Uint16Array( 4 * 2 );
		read( grid );
		print( grid );
	}
	
	function print( grid ) {
		if( !console ) {
			return;
		}
		
		console.log( 'Grid state:' );
		
		var
		i, j,
		row, cell, o,
		pad = '        ';
		
		for( j = 0; j < 4; ++ j ) {
			o = '';
			row = grid[j];
			for( i = 0; i < 4; ++ i ) {
				cell = (row >>> (i * 4)) & 0xF;
				if( !cell ) {
					o += pad + ' |';
				} else {
					o += pad.substr( String( cell ).length ) + cell + ' |';
				}
			}
			console.log( o );
		}
	}
	
	function read( grid ) {
		var i, j, o, v, p;
		if( source && source.cells ) {
			for( j = 0; j < 4; ++ j ) {
				grid[j] = 0;
				for( i = 0; i < 4; ++ i ) {
					o = source.cells[i][j];
					v = 0, p = 0;
					if( o ) {
						v = o.value;
						if( v ) {
							for( p = 0; (1 << p) < v; ++ p );
							++ p;
						}
					}
					grid[j] |= p << (i * 4);
				}
			}
		} else {
			console.log( 'reading from HTML' );
			for( j = 0; j < 4; ++ j ) {
				grid[j] = 0;
				for( i = 0; i < 4; ++ i ) {
					o = document.getElementsByClassName( 'tile-position-' + (i + 1) + '-' + (j + 1) );
					v = 0, p = 0;
					if( o && o.length ) {
						v = +(o[o.length-1].children[0].innerText);
						if( v ) {
							for( p = 0; (1 << p) < v; ++ p );
							++ p;
						}
					}
					grid[j] |= p << (i * 4);
				}
			}
		}
	}
	
	window.autoplay = autoplay;
	window.test = test;
	
	var btnAuto = document.createElement( 'button' );
	btnAuto.appendChild( document.createTextNode( 'Play Automatically' ) );
	btnAuto.style.position = 'fixed';
	btnAuto.style.top = '5px';
	btnAuto.style.left = '5px';
	btnAuto.style.zIndex = '999999';
	btnAuto.addEventListener( 'click', function( ) {
		autoplay( );
	} );
	document.body.appendChild( btnAuto );
}

var run = false;
// Use github.io's own functions to load 2048 direct from the source!
window.addEventListener( 'load', function( ) {
	'strict mode';
	
	if( run ) {
		return;
	}
	run = true;
	
	HTMLPreview.replaceAssets = function() {
		console.log( 'Replace', location.hostname, location.pathname, location.search );
		var frame, a, link, script, i, href, src;
		frame = document.querySelectorAll('iframe[src],frame[src]');
		for(i = 0; i < frame.length; ++i) {
			src = frame[i].src; //Get absolute URL
			console.log( 'Frame', frame[i], src );
			if(src.indexOf('//raw.github.com') > 0 || src.indexOf('//bitbucket.org') > 0) { //Check if it's from raw.github.com or bitbucket.org
				frame[i].src = 'http://' + location.hostname + location.pathname + '?' + src; //Then rewrite URL so it can be loaded using YQL
			}
		}
		a = document.querySelectorAll('a[href]');
		for(i = 0; i < a.length; ++i) {
			href = a[i].href; //Get absolute URL
			console.log( 'A', href );
			if(href.indexOf('#') > 0) { //Check if it's an anchor
				a[i].href = 'http://' + location.hostname + location.pathname + location.search + '#' + a[i].hash.substring(1); //Then rewrite URL with support for empty anchor
			}
			else if(href.indexOf('//raw.github.com') > 0 || href.indexOf('//bitbucket.org') > 0) { //Check if it's from raw.github.com or bitbucket.org
				a[i].href = 'http://' + location.hostname + location.pathname + '?' + href; //Then rewrite URL so it can be loaded using YQL
			}
		}
		if(document.querySelectorAll('frameset').length)
			return; //Don't replace CSS/JS if it's a frameset, because it will be erased by document.write()
		link = document.querySelectorAll('link[rel=stylesheet]');
		for(i = 0; i < link.length; ++i) {
			href = link[i].href; //Get absolute URL
			console.log( 'Link', href );
			if(href.indexOf('//raw.github.com') > 0 || href.indexOf('//bitbucket.org') > 0) { //Check if it's from raw.github.com or bitbucket.org
				HTMLPreview.send(href, 'loadCSS'); //Then load it using YQL
			}
		}
		script = document.querySelectorAll('script');
		for(i = 0; i < script.length; ++i) {
			src = script[i].src; //Get absolute URL
			console.log( 'Script', href );
			if(src.indexOf('//raw.github.com') > 0 || src.indexOf('//bitbucket.org') > 0) { //Check if it's from raw.github.com or bitbucket.org
				HTMLPreview.send(src, 'loadJS'); //Then load it using YQL
			}
			else if(!src && script[i].innerHTML.indexOf('HTMLPreview') < 0) { //Move all inline scripts except HTMLPreview.replaceAssets()
				document.write(script[i].outerHTML);
			}
		}
	};
	HTMLPreview.send( 'https://raw.github.com/gabrielecirulli/2048/master/index.html', 'loadHTML' );
	
	setTimeout( makeAI, 5000 );
} );
</script>
</head>
<body>
Loading game&hellip;
</body>
</html>